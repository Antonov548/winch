---
output: downlit::readme_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
pkgload::load_all()
```

# winch

<!-- badges: start -->
[![Lifecycle: experimental](https://img.shields.io/badge/lifecycle-experimental-orange.svg)](https://www.tidyverse.org/lifecycle/#experimental)
<!-- badges: end -->

The goal of winch is to provide stack traces that combine R and C function calls.
This is primarily useful for developers of R packages where a substantial portion of the code is C or C++.


## Installation

Once on CRAN, you can install the released version of winch from [CRAN](https://CRAN.R-project.org) with:

``` r
install.packages("winch")
```

Install the development version from GitHub with:

``` r
devtools::install_github("r-lib/winch")
```

## Example

This is an example where an R function calls into C which calls back into R, see the second-to-last entry in the trace:

```{r example}
library(winch)

foo <- function() {
  winch_call(bar)
}

bar <- function() {
  winch_trace_back()
}

foo()
```

`rlang::entrace()` checks if winch is installed, and adds a native backtrace.
This cannot be easily demonstrated in a knitr document, the output is copied from [this GitHub Actions run](https://github.com/r-prof/winch/pull/25/checks?check_run_id=1105304366#step:12:33).

```{r error, eval = FALSE}
options(error = rlang::entrace, rlang_backtrace_on_error = "full")

vctrs::vec_as_location(quote, 2)
```

```
##[error]Error: Must subset elements with a valid subscript vector.
✖ Subscript has the wrong type `function`.
ℹ It must be logical, numeric, or character.
Backtrace:
    █
 1. ├─vctrs::vec_as_location(quote, 2)
 2. │ └─`/vctrs.so`::vctrs_as_location()
 3. └─rlang::cnd_signal(...)
Backtrace:
    █
 1. └─vctrs::vec_as_location(quote, 2)
 2.   └─`/vctrs.so`::vctrs_as_location()
 3.     └─`/vctrs.so`::vec_as_location_opts()
 4.       └─rlang::cnd_signal(...)
 5.         └─rlang:::signal_abort(cnd)
```


## How does it work?

It's a very crude heuristic.
R's traceback (and also profiling) infrastructure introduces the notion of a "context".
Every call to an R function opens a new context, and closes it when execution of the function ends.
Unfortunately, no new context is established for native code called with `.Call()` or `.External()`.
Establishing contexts requires precious run time, this might be the reason for this omission.

To work around this limitation, the source code of all R functions along the call chain is scanned for instances of `.Call` and `.External`.
The native call stack (obtained via libunwind or libbacktrace) is scanned for chunks of code outside of `libR.so` (R's main library) -- these are assumed to correspond to `.Call()` or `.External()`.
The native traces are embedded as artificial calls into the R stack trace.

## Limitations

- The matching will not be perfect, it still may lead to quicker discovery of the cause of an error.
- Windows only works on x64, and there the traces can be obtained only for one shared library at a time. See `winch_init_library()` for details.

---

## Code of Conduct

Please note that the winch project is released with a [Contributor Code of Conduct](https://contributor-covenant.org/version/2/0/CODE_OF_CONDUCT.html). By contributing to this project, you agree to abide by its terms.
